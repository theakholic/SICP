#lang racket



(define (filter predicate sequence)
  (cond [(empty? sequence) '()]
        [(predicate (first sequence))
         (cons (first sequence)
               (filter predicate (rest sequence)))]
        [else (filter predicate (rest sequence))]))
        


(filter odd? (list 1 2 3 4 5 6 7 8 9))

(define (accumulate op initial sequence) ;op -> operation
  (cond [(empty? sequence) initial]
        [(cons? (first sequence))
          (op (accumulate op initial (first sequence))
              (accumulate op initial (rest sequence)))]
        [else (op (first sequence)
                  (accumulate
                   op
                   initial
                   (rest sequence)))]))

(accumulate + 0 (list 1 2 3 4 5))

(accumulate * 1 (list 1 2 3 4 5))

(accumulate cons '() (list 1 2 3 4 5))


(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(enumerate-interval 2 7)

(define (enumerate-tree tree) ;fringe!
  (cond [(empty? tree) '()]
        [(not (cons? tree)) (cons tree empty)]
        [else (append (enumerate-tree (first tree))
                    (enumerate-tree (rest tree)))]))

(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
(enumerate-tree (list (list 1 2) (list 3 4 5) (list 8 9 10) 11))


(define (sum-odd-squares tree)
 (accumulate + 0 (map sqr
                  (filter odd? (enumerate-tree tree)))))

(sum-odd-squares (list 1 (list 2 (list 3 4) (list 5 6))))

(define (fib n)
  (if (or (= 0 n) (= 1 n))
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

(define (odd-fibs n)
  (accumulate cons '()
              (filter odd? (map fib (enumerate-interval 0 n)))))

(odd-fibs 20)
